# uCode
## Kick-off
### C -- Useful links

Материал по C: 
1. [The C Book](https://publications.gbdirect.co.uk//c_book/the_c_book.pdf) — Подробный гайд по C
2. [Essential C](http://cslibrary.stanford.edu/101/EssentialC.pdf)  — Расширенный Cheat Sheet
3. [Набор разный шпаргалок](https://www.rankred.com/useful-c-cheat-sheets/) 
4. [Awesome C](https://github.com/aleksandar-todorovic/awesome-c)  — Список полезной информации от А-Я

### C -- notes 00

Переменные и строки

```C
int main() { // Объявление функции в скобках могут быть аргументы

int x, y, z; // Так можно объявить переменную и задать ей тип

x = 7 // Так присваивается значение для переменных

float f = 5.9428; // Так тоже можно делать 

int o = 50, n = 70, res; // Неполноценный ответ к вопросу выше

char sym = 'D';

printf("Num is %d, f is %.3f\n", x, f); // Это что-то на подобие старых f строк в питоне. Возможные значения с %:
%s - string
%d - int 
%.3f - float если перед ним точка с цыфрой это означает сколько выводить точек после запятой 
// |
// | Больше про формат строки
// ↓
}
```
[Больше про f строки](https://ru.wikipedia.org/wiki/Printf)


Математические операции

```C
int main(){

int x = 20, y = 32, res;
res = x % y; // Также можно использовать += и тд 
res += 1 // Можно делать res++ и -- это постфиксные есть еще префиксные операторы они работают раньше например если я хочу запринтить с 	 // постфиксным он сразу выведет число и только после этого сделает свою операцию

printf("Res is %d\n), res);

int age;

printf("Enter your age: ");
scanf("%d", &age); // Знак & говорит что мы записываем значение в пременую 

printf("Your age is: %d\n", age)

}
```

Условные операторы

```C
int main(){

int age;

printf("Enter your age: ");
scanf("%d, &age);

if (age > 18) // Так работает однострочные if
	printf("Your age is bigger than 18. Age is %d\n", age);
	// Если нужно больше строк нужно добавить {} также в однострочном можно использовать else 
	// Есть еще такой формат записи <exp 1> ? <Yes> : <No>

}
```
 
### C -- notes 01
Указатели
```C
int main(){
					       Pointers Basic
    /*-------------------------------------------------------------------------------------------------*/
    
    int k // Обьявлю просто переменую типа int | Если вывести k получим 32764 ? Почему
    int *ptr // Обьявляю пременную-индикатор | Если вывести ptr получим 0 
    
    k = 2000 // Присваеваем переменой k значение 2000
    ptr = &k // Присваеваем переменой ptr адресс переменой k
    
    *ptr = 7 // Присвоем переменой на которую указывает наш ptr значение 7 | Тперь k == 7 != 2000 :)
    
    
    /*-------------------------------------------------------------------------------------------------*/
    					   Pointer types and Arrays
    /*-------------------------------------------------------------------------------------------------*/
    int my_array[] = {1,23,17,4,-5,100}; // Так можно обьявить масив. В квадратных скобках можно указать размер 
    
    //Получить доступ к елементам масива можно так:
    	my_array[0]; // == 1;
	my_array[1]; // == 23
	// ...
    	
	int *ptr;
	ptr = &my_array[0]; // == 1 // Или Так ptr = my_array
	ptr += 1; // == 23
    /*-------------------------------------------------------------------------------------------------*/
    
    
}
```
Побитовые операции
```C
int main(){

   \\ Побитовое И (AND)
   \\ Можно проверить число на честность\нечестность
   \\ Например:
   
   int a = 100 & 1 == 0;
   int b = 9 & 1 == 1;
   
   
   \\ Исключающее ИЛИ (XOR)
   \\ Можно использовать как шифратор или поменять переменую местами 
   \\ Например:
   
   int a = 5;
   int b = 10;

   a = (b ^ a) ^ a; == 10 || b = (b ^ a) ^ b; == 5
   
   \\ Побитовый сдвиг влево
   \\ Интересной особенностью сдвига влево на N позиций является то, что это эквивалентно умножению числа на 2N.
   \\ Например:
   
   43<<4 == 43*Math.pow(2,4);
   
   
   // Пример программы с объяснениями
   int bit_count(long n) {
	int bits = 0;          // Так отнимаеться один разряд справа налева // Таким образом из 255 в 2 отнимая по одному 				 // биту -127 в 2 получим 128
	for(int bit = 0; n > 0; n &= ~(1 << bit), bit++) {
		                                        // Так получаем десятичынй разряд для проверки | 1 << bit == 2**bit
/* Проверяем бит на совпадение    */    if(n & (1 << bit)) {
/* Например n ==  255 == 11111111 */    bits++;
/* 1 << bit =            00000001 */	printf("bits = %d | bit = %d | n = %d\n", bits, bit, n);
/* 255 & 1  =                   1 */	printf("n &= ~(1 << bit) = %d | n & (1 << bit) = %d\n\n", n & ~(1 << bit), n & (1 << bit));
/* Так проверяем для каждого бита в байте */
		}
	}
	return bits;
}
   
}
```
